{*******************************************************}
{                                                       }
{               HCView V1.0  作者：荆通                 }
{                                                       }
{      本代码遵循BSD协议，你可以加入QQ群 649023932      }
{            来获取更多的技术交流 2018-5-4              }
{                                                       }
{                    表格行实现单元                     }
{                                                       }
{*******************************************************}

unit HCTableRow;

interface

uses
  HCCustomData, HCTableCell, HCTableCellData, HCStyle;

const
  MinRowHeight = 20;
  MinColWidth = 10;
  MaxListSize = Maxint div 16;

type
  PPointerList = ^TPointerList;
  TPointerList = array[0..MaxListSize] of Pointer;

  TTableRow = class(TObject)
  private
    FList: PPointerList;
    FColCount,
    FCapacity,
    FHeight,  // 行高，不带上下边框 = 行中单元格最高的(单元格高包括单元格为分页而在某行额外偏移的高度)
    FFmtOffset  // 格式化时的偏移，主要是处理当前行整体下移到下一页时，简化上一页底部的鼠标点击、移动时的计算
      : Integer;
    FAutoHeight: Boolean;  // True根据内容自动匹配合适的高度 False用户拖动后的自定义高度
    procedure SetCapacity(const Value: Integer);
    function GetItems(Index: Integer): Pointer;
    procedure SetItems(Index: Integer; const Value: Pointer);
    procedure SetColCount(const Value: Integer);
  protected
    function GetCols(Index: Integer): TTableCell;

    property Items[Index: Integer]: Pointer read GetItems write SetItems; default;
  public
    constructor Create(const AStyle: THCStyle; const AColCount: Integer);
    destructor Destroy; override;
    function Add(Item: Pointer): Integer;
    function Insert(Index: Integer; Item: Pointer): Boolean;
    procedure Clear;
    procedure Delete(Index: Integer);
    function ClearFormatExtraHeight: Integer;
    //
    //function CalcFormatHeight: Integer;
    procedure SetRowWidth(const AWidth: Integer);
    procedure SetHeightEx(const Value: Integer);  // 外部拖动改变行高

    //property Capacity: Integer read FCapacity write SetCapacity;
    property ColCount: Integer read FColCount write SetColCount;
    //property List: PCellDataList read FList;
    //
    property Cols[Index: Integer]: TTableCell read GetCols;

    /// <summary> 当前行中所有没有发生合并单元格的高度(含CellVPadding * 2因为会受有合并列的影响，所以>=数据高度) </summary>
    property Height: Integer read FHeight write FHeight;
    property AutoHeight: Boolean read FAutoHeight write FAutoHeight;

    /// <summary>因跨页向下整体偏移的量</summary>
    property FmtOffset: Integer read FFmtOffset write FFmtOffset;
  end;

implementation

uses
  SysUtils, Math;

{ TTableRow }

function TTableRow.Add(Item: Pointer): Integer;
begin
  if FColCount = FCapacity then
    SetCapacity(FCapacity + 4);  // 每次扩充4个
  FList^[FColCount] := Item;
  Result := FColCount;
  Inc(FColCount);
end;

function TTableRow.Insert(Index: Integer; Item: Pointer): Boolean;
begin
  if (Index < 0) or (Index > FColCount) then
    raise Exception.CreateFmt('[Insert]非法数据:%d', [Index]);
  if FColCount = FCapacity then
    SetCapacity(FCapacity + 4);  // 每次扩充4个
  if Index < FColCount then
    System.Move(FList^[Index], FList^[Index + 1],
      (FColCount - Index) * SizeOf(Pointer));
  FList^[Index] := Item;
  Inc(FColCount);
  Result := True;
end;

procedure TTableRow.SetRowWidth(const AWidth: Integer);
var
  i, vWidth: Integer;
begin
  vWidth := AWidth div FColCount;
  for i := 0 to FColCount - 2 do
  begin
    {if i = 0 then
      Cols[i].CellData.Items[0].Text := Cols[i].CellData.Items[0].Text + 'aaaaaa患者';
    if i = 1 then
    begin
      Cols[i].CellData.Items[0].StyleNo := 1;
      Cols[i].CellData.Items[0].Text := '12345678910';
    end;}
    Cols[i].Width := vWidth;
  end;
  Cols[FColCount - 1].Width := AWidth - (FColCount - 1) * vWidth;  // 结余的全部给最后一个单元格
end;

{function TTableRow.CalcFormatHeight: Integer;
var
  i, vH: Integer;
begin
  Result := MinRowHeight;
  for i := 0 to FColCount - 1 do
  begin
    if Cols[i] <> nil then
    begin
      vH := Cols[i].DrawItems[Cols[i].DrawItems.Count - 1].Rect.Bottom
        + Cols[i].DrawItems[Cols[i].DrawItems.Count - 1].TopOffset;

      if vH > Result then
        Result := vH;
    end;
  end;
end;}

procedure TTableRow.Clear;
begin
  SetColCount(0);
  SetCapacity(0);
end;

constructor TTableRow.Create(const AStyle: THCStyle; const AColCount: Integer);
var
  vCell: TTableCell;
  i: Integer;
begin
  FColCount := 0;
  FCapacity := 0;
  for i := 0 to AColCount - 1 do
  begin
    vCell := TTableCell.Create(AStyle);
    Add(vCell);
  end;
  FAutoHeight := True;
end;

procedure TTableRow.Delete(Index: Integer);
begin
  if (Index < 0) or (Index >= FColCount) then
    raise Exception.CreateFmt('[Delete]非法的 Index:%d', [Index]);
  TTableCell(FList^[Index]).Free;
  if Index < FColCount then
    System.Move(FList^[Index + 1], FList^[Index], (FColCount - Index) * SizeOf(Pointer));
  Dec(FColCount);
end;

destructor TTableRow.Destroy;
begin
  Clear;
  inherited;
end;

function TTableRow.GetCols(Index: Integer): TTableCell;
begin
  Result := TTableCell(Items[Index]);
end;

function TTableRow.ClearFormatExtraHeight: Integer;
var
  i, vMaxDiff: Integer;
begin
  Result := FFmtOffset;
  FFmtOffset := 0;
  vMaxDiff := 0;
  for i := 0 to ColCount - 1 do
    vMaxDiff := Max(vMaxDiff, Cols[i].ClearFormatExtraHeight);

  if vMaxDiff > 0 then
  begin
    for i := 0 to ColCount - 1 do
      Self.Cols[i].Height := Self.Cols[i].Height - vMaxDiff;
    FHeight := FHeight - vMaxDiff;
  end;

  Result := Result + vMaxDiff;
end;

function TTableRow.GetItems(Index: Integer): Pointer;
begin
  if (Index < 0) or (Index >= FColCount) then
    raise Exception.CreateFmt('异常:[TTableRow.GetItems]参数Index值%d超出范围！', [Index]);
  Result := FList^[Index];
end;

procedure TTableRow.SetCapacity(const Value: Integer);
begin
  if (Value < FColCount) or (Value > MaxListSize) then
    raise Exception.CreateFmt('[SetCapacity]非法数据:%d', [Value]);
  if FCapacity <> Value then
  begin
    // 重新分配指定大小内存块，参数P必须是nil或者指向一个由
    // GetMem, AllocMem, 或 ReallocMem分配的内存变量，其分配的内存是连续的，
    // 会把前面已有的数据移到新分配的内存中去
    ReallocMem(FList, Value * SizeOf(Pointer));
    FCapacity := Value;
  end;
end;

procedure TTableRow.SetColCount(const Value: Integer);
var
  i: Integer;
begin
  if (Value < 0) or (Value > MaxListSize) then
    raise Exception.CreateFmt('[SetCount]非法数据:%d', [Value]);
  if Value > FCapacity then
    SetCapacity(Value);
  if Value > FColCount then
    FillChar(FList^[FColCount], (Value - FColCount) * SizeOf(Pointer), 0)
  else
    for i := FColCount - 1 downto Value do
      Delete(I);
  FColCount := Value;
end;

procedure TTableRow.SetHeightEx(const Value: Integer);
var
  i: Integer;
begin
  // 找行中最高的单元格
  for i := 0 to FColCount - 1 do
  begin
    if Cols[i].CellData <> nil then
    begin
      if Cols[i].CellData.Height > FHeight then
        FHeight := Cols[i].CellData.Height;
    end;
  end;
  if FHeight < Value then  // 处理行中最高内容是否能放下
    FHeight := Value;
  for i := 0 to FColCount - 1 do
  begin
    if Cols[i].CellData.Height > FHeight then
      Cols[i].Height := FHeight;
  end;
end;

procedure TTableRow.SetItems(Index: Integer; const Value: Pointer);
begin
  if (Index < 0) or (Index >= FColCount) then
    raise Exception.CreateFmt('[SetItems]异常:%d', [Index]);

  if Value <> FList^[Index] then
    FList^[Index] := Value;
end;

end.
